{
  "name": "loadbalancer",
  "version": "0.9.26",
  "description": "Load balancer for SocketCluser",
  "keywords": [
    "loadbalancer",
    "proxy",
    "socketcluster"
  ],
  "author": {
    "name": "Jonathan Gros-Dubois"
  },
  "contributors": [
    {
      "name": "Jonathan Gros-Dubois"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/SocketCluster/loadbalancer.git"
  },
  "dependencies": {
    "async": "0.9.0",
    "expirymanager": "0.9.x",
    "forever": "0.13.0",
    "minimist": "1.1.0"
  },
  "devDependencies": {
    "mocha": "1.20.x"
  },
  "bin": {
    "loadbalancer": "bin/cli.js"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "mocha": "mocha",
    "test": "npm run mocha"
  },
  "readme": "LoadBalancer.js\n============\n\nLoadBalancer.js is a sticky-session TCP load balancer which is optimized to work with realtime frameworks (with support for HTTP long polling fallbacks).\nIt captures raw TCP connections from a specified port and forwards them to various targets (defined as host and port combinations).\nIt chooses the appropriate target based on a hash of the client's IP address.\n\nLoadBalancer.js was originally designed to work with SocketCluster (http://socketcluster.io) but it can work equally well with any other realtime framework.\n\nOnce a client establishes its first successful connection/request with a target, all subsequent \nconnections/requests from that client will stick to that same target unless that target crashes or goes offline (or the session times out).\n\nLoadBalancer.js handles target failures transparently. New connections can never fail so long as there is at least one active target -\nLoadBalancer.js will automatically rollback connections to bad targets behind the scenes without the client noticing.\n\nNote that because targets are chosen based on each client's IP address, it is possible that a popular IP address could cause many sockets to be routed\nto the same target. See http://techcrunch.com/2007/01/01/wikipedia-bans-qatar/.\nThis is only likely to be a problem if you are using relatively weak target servers that cannot handle more than a few thousand concurrent user.\nIf your servers are sufficiently beefy, they should be able to handle slightly uneven loads. The beefier your target servers are, the better (so use more cores).\nOn average, you can expect pretty good distribution between targets.\n\nNote that large targets which have many active clients tend to lose clients as a faster rate than those who have fewer clients (it's a ratio).\nSince the incoming steam of clients to each target is a constant, you can expect targets to naturally regain equilibrium some time after an imbalance\n(such as one that could arise when a target crashes).\n\n## Install\n\n```bash\nnpm install -g loadbalancer\n```\n\n## Config\n\nTo run LoadBalancer.js, you just need to provide it with a config file (use --config some/path/config.json command line argument).\nHere is a sample config file showing the most basic options necessary:\n\n```json\n{\n  \"sourcePort\": 80,\n  \"targets\": [\n    {\n      \"host\": \"localhost\",\n      \"port\": 8000\n    },\n    {\n      \"host\": \"localhost\",\n      \"port\": 8001\n    }\n  ]\n}\n```\n\nHere is a sample config file showing all available options:\n\n```json\n{\n  \"sourcePort\": 80,\n  \"balancerCount\": 1,\n  \"targetDeactivationDuration\": 60000,\n  \"sessionExpiry\": 30000,\n  \"downgradeToUser\": \"someuser\", \n  \"balancerControllerPath\": \"../balancer.js\",\n  \"targets\": [\n    {\n      \"host\": \"localhost\",\n      \"port\": 8000\n    },\n    {\n      \"host\": \"localhost\",\n      \"port\": 8001\n    }\n  ]\n}\n```\n\n#### Options\n\n- **sourcePort** - The port that this load balancer will listen on.\n- **balancerCount** - [Optional - Defaults to available number of CPU cores] The number of load balancer processes to spawn.\n- **targetDeactivationDuration** - [Optional - Defaults to 60000] How long (in milliseconds) a target will be considered to be inactive after it fails to handle a connection before LoadBalancer will try again.\n- **sessionExpiry** - [Optional - Defaults to 30000] How long (in milliseconds) after a client severed all connections to target before expiring the session.\n- **downgradeToUser** - [Optional - Defaults to null] If you're launching LoadBalancer.js as root, you may wish to downgrade the permissions after launch for security purposes - This can be a Linux username or UID.\n- **balancerControllerPath** - [Optional - Defaults to null] The path to your balancerController script which you can use to block incoming connections before they are processed by LoadBalancer.js.\n- **targets** - An array of target servers to forward connections to (LoadBalancer.js will spread the load between them).\n\n## How to run\n\nOn Linux, make sure you have root privileges (sudo) - This is necessary if you want to bind to port 80.\nYou may want to use the downgradeToUser option to downgrade to a different user after launch for extra security.\n\n#### Start\n```bash\nloadbalancer start --config my/path/config.json\n```\n\n#### Stop\n```bash\nloadbalancer stop\n```\n\n## Middleware\n\nLoadBalancer.js does balancing at the TCP layer - This is great for performance and also means that it can work with HTTPS without having to supply it with a certificate.\nThe downside is that target servers will not be able to see the clients' IP addresses (on a target server; req.connection.remoteAddress will in fact be the \nLoadBalancer's IP address and not the client's) - This means that if you want to do things like block a client based on their IP address, you will have to do it at the load balancer level.\nFor this purpose, LoadBalancer.js lets you specify a balancerController script which allows you to define middleware which you can use to block incoming \nconnections before they are handled by LoadBalancer.js.\n\nHere is what the content of your balancerController script should look like:\n\n```js\nmodule.exports.run = function (balancer) {\n  balancer.addMiddleware(balancer.MIDDLEWARE_CONNECTION, function (socket, next) {\n    // You can use whatever logic you want in order to decide whether or \n    // not to process this connection\n    if (...) {\n      // Allow connection to go through\n      next();\n    } else {\n      // Block connection\n      next('Blocked connection from client with IP: ' + socket.remoteAddress);\n    }\n  });\n};\n```\n\n## License\n\nMIT",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/SocketCluster/loadbalancer/issues"
  },
  "_id": "loadbalancer@0.9.26",
  "dist": {
    "shasum": "f8744e687ecbfb69aa87eb0112a9594c4b8a878b"
  },
  "_from": "loadbalancer@",
  "_resolved": "https://registry.npmjs.org/loadbalancer/-/loadbalancer-0.9.26.tgz"
}
